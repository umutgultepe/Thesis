/*
-----------------------------------------------------------------------------
Filename:    InturlamDressingRoom.cpp
-----------------------------------------------------------------------------


This source file is generated by the
___                   _              __    __ _                  _ 
/___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
//  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
|___/                 |_|   |_|                                 
Ogre 1.7.x Application Wizard for VC10 (July 2011)
http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "StdAfx.h"
#include "InturlamDressingRoom.h"
#define Y_OFFSET 50
#define SCALING_FACTOR 5
#define MODEL_TORSO_HEIGHT 1180 //mm
#define MODEL_SHOULDER_WIDTH 450 //mm
#define COLLISION_SPHERE_COUNT 28
#define COLLISION_CAPSULE_COUNT 25

#define MODIFY_RADII 20


float userWidthScale=1;
float userHeightScale=1;
float userDepthScale=1;

extern float sphereRadii[];
extern float estimatedShoulderWidth;
extern float estimatedTorsoHeight;
extern float estimatedBodyHeight;

using namespace Ogre;

int numberOfCapsules=0;


OgreBites::ParamsPanel* help;
PxClothCollisionData col_data;
physx::PxClothCollisionSphere* box_collider;
std::vector<float> radii;
std::vector<Ogre::SceneNode*> ListedNodes;
//-------------------------------------------------------------------------------------
InturlamDressingRoom::InturlamDressingRoom(void)
{
	simulating=true;
	firstStep=true;
	simulationCreated=false;
	gDefaultFilterShader=PxDefaultSimulationFilterShader;
	currentClothIndex=INITIAL_CLOTH_INDEX;
	gPhysicsSDK=0;
	gScene=0;
	mKinect=0;
	usingGPU=true;
	upperCloth=0;
	lowerCloth=0;
	mNui=0;
	bodyRotation=Ogre::Quaternion::IDENTITY;
	targetRadii=20;
}
//-------------------------------------------------------------------------------------
InturlamDressingRoom::~InturlamDressingRoom(void)
{
	if (mNui)
		delete mNui;
	if (box_collider)
		delete [] box_collider;
	if (gPhysicsSDK)
	{
		gScene->release();
		if (mCudaContextManager)
			mCudaContextManager->release();
		mCpuDispatcher->release();
		gManager->release();
		gPhysicsSDK->release();
		gFoundation->release();
	}
	
}
Ogre::OverlayElement* SetupDepthMaterial()
{
	// Create the texture
	Ogre::TexturePtr depthTexture = Ogre::TextureManager::getSingleton().createManual(
		"MyDepthTexture", // name
		ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		TEX_TYPE_2D,      // type
		m_Width, m_Height,         // width & height
		0,                // number of mipmaps
		PF_BYTE_BGRA,     // pixel format
		TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);


	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(
		"DepthTextureMaterial", // name
		ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState("MyDepthTexture");
	material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);

	Ogre::OverlayElement* mDepthPanel = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","DepthPanel");
	mDepthPanel->setMaterialName("DepthTextureMaterial");
	mDepthPanel->setMetricsMode(Ogre::GMM_PIXELS);
	mDepthPanel->setWidth(320);
	mDepthPanel->setHeight(240);
	mDepthPanel->setHorizontalAlignment(GHA_RIGHT);
	mDepthPanel->setVerticalAlignment(GVA_BOTTOM);
	mDepthPanel->setLeft(-mDepthPanel->getWidth());
	mDepthPanel->setTop(-mDepthPanel->getHeight());
	return mDepthPanel;
}

extern IplImage* tImage;
extern bool textureUpdated;

void updateDepthTexture()
{
	if (tImage && textureUpdated)
	{
		//Depth texture
		TexturePtr texture = TextureManager::getSingleton().getByName("MyDepthTexture");
		HardwarePixelBufferSharedPtr pixelBuffer = texture->getBuffer();// Get the pixel buffer
		pixelBuffer->lock(HardwareBuffer::HBL_DISCARD); // Lock the pixel buffer and get a pixel box
		const PixelBox& pixelBox = pixelBuffer->getCurrentLock();
		unsigned char* pDest = static_cast<unsigned char*>(pixelBox.data);

		for( int y = 0 ; y < m_Height ; y++ )
		{
			pDest = static_cast<unsigned char*>(pixelBox.data) + y*pixelBox.rowPitch*4;
			BYTE* dPtr=(BYTE*)(tImage->imageData+y*tImage->widthStep);
			for( int x = 0 ; x < m_Width ; x++ )
			{
				*pDest++ = *dPtr++;	// write to output buffer
				*pDest++ =  *dPtr++;	// write to output buffer
				*pDest++ = *dPtr++;	// write to output buffer
				*pDest++ =  255;	// write to output buffer
			}

		}
		pixelBuffer->unlock();
		textureUpdated=false;
	}	
}

void InturlamDressingRoom::createCapsule(const Ogre::String& strName, const float r,const float r2,const float d, const int nRings , const int nSegments )
{
	MeshPtr pSphere = MeshManager::getSingleton().createManual(strName, ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	SubMesh *pSphereVertex = pSphere->createSubMesh();

	pSphere->sharedVertexData = new VertexData();
	VertexData* vertexData = pSphere->sharedVertexData;

	// define the vertex format
	VertexDeclaration* vertexDecl = vertexData->vertexDeclaration;
	size_t currOffset = 0;
	// positions
	vertexDecl->addElement(0, currOffset, VET_FLOAT3, VES_POSITION);
	currOffset += VertexElement::getTypeSize(VET_FLOAT3);
	// normals
	vertexDecl->addElement(0, currOffset, VET_FLOAT3, VES_NORMAL);
	currOffset += VertexElement::getTypeSize(VET_FLOAT3);
	// two dimensional texture coordinates
	vertexDecl->addElement(0, currOffset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0);
	currOffset += VertexElement::getTypeSize(VET_FLOAT2);

	// allocate the vertex buffer
	vertexData->vertexCount = (nRings + 1) * (nSegments+1);
	HardwareVertexBufferSharedPtr vBuf = HardwareBufferManager::getSingleton().createVertexBuffer(vertexDecl->getVertexSize(0), vertexData->vertexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY, false);
	VertexBufferBinding* binding = vertexData->vertexBufferBinding;
	binding->setBinding(0, vBuf);
	float* pVertex = static_cast<float*>(vBuf->lock(HardwareBuffer::HBL_DISCARD));

	// allocate index buffer
	pSphereVertex->indexData->indexCount = 6 * nRings * (nSegments + 1);
	pSphereVertex->indexData->indexBuffer = HardwareBufferManager::getSingleton().createIndexBuffer(HardwareIndexBuffer::IT_16BIT, pSphereVertex->indexData->indexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY, false);
	HardwareIndexBufferSharedPtr iBuf = pSphereVertex->indexData->indexBuffer;
	unsigned short* pIndices = static_cast<unsigned short*>(iBuf->lock(HardwareBuffer::HBL_DISCARD));

	float fDeltaRingAngle = (Math::PI / nRings);
	float fDeltaSegAngle = (2 * Math::PI / nSegments);
	unsigned short wVerticeIndex = 0 ;

	// Generate the group of rings for the sphere
	for( int ring = 0; ring <= nRings/2; ring++ ) {
		float r0 = r * sinf (ring * fDeltaRingAngle);
		float y0 = d+r * cosf (ring * fDeltaRingAngle);

		// Generate the group of segments for the current ring
		for(int seg = 0; seg <= nSegments; seg++) {
			float x0 = r0 * sinf(seg * fDeltaSegAngle);
			float z0 = r0 * cosf(seg * fDeltaSegAngle);

			// Add one vertex to the strip which makes up the sphere
			*pVertex++ = x0;
			*pVertex++ = y0;
			*pVertex++ = z0;

			Vector3 vNormal = Vector3(x0, y0, z0).normalisedCopy();
			*pVertex++ = vNormal.x;
			*pVertex++ = vNormal.y;
			*pVertex++ = vNormal.z;

			*pVertex++ = (float) seg / (float) nSegments;
			*pVertex++ = (float) ring / (float) nRings;

			if (ring != nRings) {
				// each vertex (except the last) has six indices pointing to it
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex;               
				*pIndices++ = wVerticeIndex + nSegments;
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex + 1;
				*pIndices++ = wVerticeIndex;
				wVerticeIndex ++;
			}
		}; // end for seg
	} // end for ring



	for( int ring = nRings/2+1; ring <= nRings; ring++ ) {
		float r0 = r2 * sinf (ring * fDeltaRingAngle);
		float y0 = r2 * cosf (ring * fDeltaRingAngle);

		// Generate the group of segments for the current ring
		for(int seg = 0; seg <= nSegments; seg++) {
			float x0 = r0 * sinf(seg * fDeltaSegAngle);
			float z0 = r0 * cosf(seg * fDeltaSegAngle);

			// Add one vertex to the strip which makes up the sphere
			*pVertex++ = x0;
			*pVertex++ = y0;
			*pVertex++ = z0;

			Vector3 vNormal = Vector3(x0, y0, z0).normalisedCopy();
			*pVertex++ = vNormal.x;
			*pVertex++ = vNormal.y;
			*pVertex++ = vNormal.z;

			*pVertex++ = (float) seg / (float) nSegments;
			*pVertex++ = (float) ring / (float) nRings;

			if (ring != nRings) {
				// each vertex (except the last) has six indices pointing to it
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex;               
				*pIndices++ = wVerticeIndex + nSegments;
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex + 1;
				*pIndices++ = wVerticeIndex;
				wVerticeIndex ++;
			}
		}; // end for seg
	} // end for ring




	// Unlock
	vBuf->unlock();
	iBuf->unlock();
	// Generate face list
	pSphereVertex->useSharedVertices = true;

	// the original code was missing this line:
	pSphere->_setBounds( AxisAlignedBox( Vector3(-r-r2, -r2, -r-r2), Vector3(r+r2, r+d, r+r2) ), false );
	pSphere->_setBoundingSphereRadius(r+d);
	// this line makes clear the mesh is loaded (avoids memory leaks)
	pSphere->load();
}

void InturlamDressingRoom::createSphere(const float r, const int nRings, const int nSegments)
{
	MeshPtr pSphere = MeshManager::getSingleton().createManual("sphere_r"+StringConverter::toString(r), ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	SubMesh *pSphereVertex = pSphere->createSubMesh();

	pSphere->sharedVertexData = new VertexData();
	VertexData* vertexData = pSphere->sharedVertexData;

	// define the vertex format
	VertexDeclaration* vertexDecl = vertexData->vertexDeclaration;
	size_t currOffset = 0;
	// positions
	vertexDecl->addElement(0, currOffset, VET_FLOAT3, VES_POSITION);
	currOffset += VertexElement::getTypeSize(VET_FLOAT3);
	// normals
	vertexDecl->addElement(0, currOffset, VET_FLOAT3, VES_NORMAL);
	currOffset += VertexElement::getTypeSize(VET_FLOAT3);
	// two dimensional texture coordinates
	vertexDecl->addElement(0, currOffset, VET_FLOAT2, VES_TEXTURE_COORDINATES, 0);
	currOffset += VertexElement::getTypeSize(VET_FLOAT2);

	// allocate the vertex buffer
	vertexData->vertexCount = (nRings + 1) * (nSegments+1);
	HardwareVertexBufferSharedPtr vBuf = HardwareBufferManager::getSingleton().createVertexBuffer(vertexDecl->getVertexSize(0), vertexData->vertexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY, false);
	VertexBufferBinding* binding = vertexData->vertexBufferBinding;
	binding->setBinding(0, vBuf);
	float* pVertex = static_cast<float*>(vBuf->lock(HardwareBuffer::HBL_DISCARD));

	// allocate index buffer
	pSphereVertex->indexData->indexCount = 6 * nRings * (nSegments + 1);
	pSphereVertex->indexData->indexBuffer = HardwareBufferManager::getSingleton().createIndexBuffer(HardwareIndexBuffer::IT_16BIT, pSphereVertex->indexData->indexCount, HardwareBuffer::HBU_STATIC_WRITE_ONLY, false);
	HardwareIndexBufferSharedPtr iBuf = pSphereVertex->indexData->indexBuffer;
	unsigned short* pIndices = static_cast<unsigned short*>(iBuf->lock(HardwareBuffer::HBL_DISCARD));

	float fDeltaRingAngle = (Math::PI / nRings);
	float fDeltaSegAngle = (2 * Math::PI / nSegments);
	unsigned short wVerticeIndex = 0 ;

	// Generate the group of rings for the sphere
	for( int ring = 0; ring <= nRings; ring++ ) {
		float r0 = r * sinf (ring * fDeltaRingAngle);
		float y0 = r * cosf (ring * fDeltaRingAngle);

		// Generate the group of segments for the current ring
		for(int seg = 0; seg <= nSegments; seg++) {
			float x0 = r0 * sinf(seg * fDeltaSegAngle);
			float z0 = r0 * cosf(seg * fDeltaSegAngle);

			// Add one vertex to the strip which makes up the sphere
			*pVertex++ = x0;
			*pVertex++ = y0;
			*pVertex++ = z0;

			Vector3 vNormal = Vector3(x0, y0, z0).normalisedCopy();
			*pVertex++ = vNormal.x;
			*pVertex++ = vNormal.y;
			*pVertex++ = vNormal.z;

			*pVertex++ = (float) seg / (float) nSegments;
			*pVertex++ = (float) ring / (float) nRings;

			if (ring != nRings) {
				// each vertex (except the last) has six indices pointing to it
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex;               
				*pIndices++ = wVerticeIndex + nSegments;
				*pIndices++ = wVerticeIndex + nSegments + 1;
				*pIndices++ = wVerticeIndex + 1;
				*pIndices++ = wVerticeIndex;
				wVerticeIndex ++;
			}
		}; // end for seg
	} // end for ring

	// Unlock
	vBuf->unlock();
	iBuf->unlock();
	// Generate face list
	pSphereVertex->useSharedVertices = true;

	// the original code was missing this line:
	pSphere->_setBounds( AxisAlignedBox( Vector3(-r, -r, -r), Vector3(r, r, r) ), false );
	pSphere->_setBoundingSphereRadius(r);
	// this line makes clear the mesh is loaded (avoids memory leaks)
	pSphere->load();
}

ManualObject* InturlamDressingRoom::createLine(Ogre::String name,Vector3 startPos,Vector3 endPos,Ogre::ColourValue color)
{
	ManualObject* myManualObject =  mSceneMgr->createManualObject(name); 

	MaterialPtr myManualObjectMaterial = MaterialManager::getSingleton().create(name+"material",Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME); 
	myManualObjectMaterial->setReceiveShadows(false); 
	myManualObjectMaterial->getTechnique(0)->setLightingEnabled(true); 
	myManualObjectMaterial->getTechnique(0)->getPass(0)->setDiffuse(color); 
	myManualObjectMaterial->getTechnique(0)->getPass(0)->setAmbient(color); 
	myManualObjectMaterial->getTechnique(0)->getPass(0)->setSelfIllumination(color); 



	myManualObject->begin(name+"material", Ogre::RenderOperation::OT_LINE_LIST); 
	myManualObject->position(startPos); 
	myManualObject->position(endPos); 
	// etc 
	myManualObject->end(); 
	return myManualObject;
}

void InturlamDressingRoom::buildAxes()
{
	SceneNode* root=mSceneMgr->getRootSceneNode()->createChildSceneNode("Axes");
	root->attachObject(createLine("xAxis",Vector3(0,0,0),Vector3(10,0,0),Ogre::ColourValue::Red));
	root->attachObject(createLine("yAxis",Vector3(0,0,0),Vector3(0,10,0),Ogre::ColourValue::Green));
	root->attachObject(createLine("zAxis",Vector3(0,0,0),Vector3(0,0,10),Ogre::ColourValue::Blue));
}

SceneNode* InturlamDressingRoom::createLimb(Ogre::String limbName,Ogre::String childNodeName,float startRadius, Ogre::Vector3 endPosition,float endRadius,Ogre::SceneNode* node,bool inheritOrientation,Quaternion orientation)
{

	float distance=endPosition.length();
	Ogre::String name="capsule"+Ogre::StringConverter::toString(numberOfCapsules++);
	createCapsule(name,endRadius,startRadius,distance);
	Ogre::Entity* limb = mSceneMgr->createEntity(limbName, name);
	node->attachObject(limb);
	Ogre::Vector3 up(0,1,0);
	Ogre::SceneNode* cNode=node->createChildSceneNode(childNodeName,Ogre::Vector3(0,distance,0));
	Ogre::Quaternion rotQ=up.getRotationTo(endPosition);
	node->setOrientation(rotQ);
	node->setInheritOrientation(inheritOrientation);
	node->setInitialState();
	node->rotate(orientation);
	return cNode;
}

SceneNode* InturlamDressingRoom::createLimb(Ogre::String limbName,float startRadius, Ogre::Vector3 endPosition,float endRadius,Ogre::SceneNode* jointNode)
{
	float distance=endPosition.length();
	Ogre::String name="capsule"+Ogre::StringConverter::toString(numberOfCapsules++);
	createCapsule(name,endRadius,startRadius,distance);
	Ogre::Entity* limb = mSceneMgr->createEntity(limbName, name);
	Ogre::Vector3 up(0,1,0);
	Ogre::SceneNode* cNode=jointNode->createChildSceneNode(limbName + " Node");
	cNode->attachObject(limb);
	Ogre::Quaternion rotQ=up.getRotationTo(endPosition);
	cNode->setOrientation(rotQ);
	cNode->setInheritOrientation(true);
	cNode->setInitialState();
	return cNode;
}


int getBoneIndex(Ogre::String boneName)
{
	for (int i=0;i<COLLISION_SPHERE_COUNT;i++)
	{
		if (boneStrings[i]==boneName)
			return i;
	}
	return COLLISION_SPHERE_COUNT;
}

const physx::PxU32 pairInd[]={	
	BONE_STOMACH,BONE_WAIST, //Stomach-To-Waist
	BONE_STOMACH,BONE_CHEST, //Stomach-To-Chest
	BONE_CHEST,BONE_LEFT_HUMERUS, //Chest-To-Left-Humerus
	BONE_LEFT_HUMERUS,BONE_LEFT_ULNA, //Left-Humerus-to-Left-Ulna
	BONE_LEFT_ULNA,BONE_LEFT_HAND,//Left-Ulna-to-Left-Hand
	BONE_CHEST,BONE_RIGHT_HUMERUS, //Chest-To-Right-Humerus
	BONE_RIGHT_HUMERUS,BONE_RIGHT_ULNA, //Right-Humerus-to-Right-Ulna
	BONE_RIGHT_ULNA,BONE_RIGHT_HAND,//Right-Ulna-to-Right-Hand
	BONE_WAIST,BONE_RIGHT_THIGH, //Waist-to-Right-Thigh
	BONE_RIGHT_THIGH,BONE_RIGHT_CALF,//Right-Thigh-To-Right-Calf
	BONE_RIGHT_CALF,BONE_RIGHT_FOOT,//Right-Calf-To-Right-Foot
	BONE_WAIST,BONE_LEFT_THIGH, //Waist-to-Left-Thigh
	BONE_LEFT_THIGH,BONE_LEFT_CALF, //Left-Thigh-To-Left-Calf
	BONE_LEFT_CALF,BONE_LEFT_FOOT,//Left-Calf-To-Left-Foot
	BONE_STOMACH,BONE_LEFT_HUMERUS, //Stomach-To-Left-Humerus
	BONE_STOMACH,BONE_RIGHT_HUMERUS, //Stomach-To-Right-Humerus
	BONE_LEG_EXTENSION_UP_L,BONE_LEG_EXTENSION_HIP_L,//LexExtension Left 1-2
	BONE_LEG_EXTENSION_HIP_L,BONE_LEG_EXTENSION_HIP2_L,//LexExtension Left 2-3
	BONE_LEG_EXTENSION_UP_R,BONE_LEG_EXTENSION_HIP_R,//LexExtension Right 1-2
	BONE_LEG_EXTENSION_HIP_R,BONE_LEG_EXTENSION_HIP2_R,//LexExtension Right 2-3
	BONE_LEFT_CALF,BONE_RIGHT_CALF,//Knee-to-Knee
	BONE_LEG_EXTENSION_HIP2_L,BONE_LEG_EXTENSION_HIP2_R,//Leg Extension 3 Left-Right
	BONE_WAIST_EXTENTION_L,BONE_WAIST_EXTENTION_R,//Waist Extent Left - Right
	BONE_WAIST_EXTENTION_L,BONE_LEG_EXTENSION_DUMMY_L,//Waist Extent -Hip Extent L 3-4
	BONE_WAIST_EXTENTION_R,BONE_LEG_EXTENSION_DUMMY_R,//Waist Extent -Hip Extent R 3-4
	
};

float radius_modifier=1;



void InturlamDressingRoom::createSphereAndCapsule(Ogre::Bone* bone,Ogre::SceneNode* parentNode,int level)
{
	if (bone->numChildren()>0 && level<8)
	{
		parentNode->setInheritOrientation(bone->getInheritOrientation());
		parentNode->setOrientation(bone->getOrientation());
		Ogre::Bone::ChildNodeIterator childIterator=bone->getChildIterator();
		while(childIterator.hasMoreElements())
		{
			Ogre::Bone* childBone=(Ogre::Bone*)childIterator.getNext();
			Ogre::Vector3 childLocalPosition=childBone->getPosition();
			Ogre::SceneNode* subJointNode=parentNode->createChildSceneNode(childBone->getName() + "Node",childLocalPosition);
			float startRadius=sphereRadii[getBoneIndex(bone->getName())]/SCALING_FACTOR;
			float endRadius = sphereRadii[getBoneIndex(childBone->getName())]/SCALING_FACTOR;
			createLimb(bone->getName()+" to "+ childBone->getName(),startRadius,childLocalPosition,endRadius,parentNode);
			createSphereAndCapsule(childBone,subJointNode,level+1);

			//Ogre::Bone* childBone=(Ogre::Bone*)childIterator.getNext();
			//Ogre::Vector3 childLocalPosition=childBone->getPosition();
			//Ogre::String limbName=bone->getName()+" to "+ childBone->getName();
			//Ogre::SceneNode* boneNode=parentNode->createChildSceneNode(limbName + " Node");
			//float startRadius=sphereRadii[getBoneIndex(bone->getName())]/SCALING_FACTOR;
			//float endRadius = sphereRadii[getBoneIndex(childBone->getName())]/SCALING_FACTOR;
			//Ogre::SceneNode* childJointNode=createLimb(limbName,childBone->getName()+"Node",startRadius,childLocalPosition,endRadius,boneNode,childBone->getInheritOrientation(),bone->getOrientation());
			//createSphereAndCapsule(childBone,childJointNode,level+1);
		}
	}
	else
	{	  
		Entity* endPart=mSceneMgr->createEntity(bone->getName()+"Sphere","sphere_r0.12");
		parentNode->attachObject(endPart);
	}
}
void InturlamDressingRoom::createVisualHuman()
{
	int mirror=1;
	createSphere(0.12);
	Ogre::Bone* RootBone=femaleBody->getSkeleton()->getBone("Root");
	rootColliderNode=clothHandle->createChildSceneNode("RootNode");
	createSphereAndCapsule(RootBone,rootColliderNode);
}

PxSceneDesc InturlamDressingRoom::initializePhysics()
{
	if (!gScene)
	{
		gFoundation=PxCreateFoundation(PX_PHYSICS_VERSION, gDefaultAllocatorCallback, gDefaultErrorCallback);
		if (!gFoundation)
		{
			MessageBox( NULL,"PxCreateFoundation failed!","Something Wrong With PhysX", MB_OK | MB_ICONERROR | MB_TASKMODAL);
			exit(0);
		}
		gManager=&PxProfileZoneManager::createProfileZoneManager(gFoundation);
		if (!gManager)
		{
			MessageBox( NULL,"Profile Zone Manager Creation failed!","Something Wrong With PhysX", MB_OK | MB_ICONERROR | MB_TASKMODAL);
			exit(0);
		}
		pxtask::CudaContextManagerDesc cudaContextManagerDesc;
		mCudaContextManager = pxtask::createCudaContextManager(*gFoundation,cudaContextManagerDesc,gManager);
		if( mCudaContextManager )
		{
			if( !mCudaContextManager->contextIsValid() )
			{
				mCudaContextManager->release();
				mCudaContextManager = NULL;
			}
		}

		gPhysicsSDK = PxCreatePhysics(PX_PHYSICS_VERSION,*gFoundation,PxTolerancesScale(),true,gManager);
		

		if(gPhysicsSDK == NULL)	
		{
			MessageBox( NULL,"Error creating PhysX3 device!","Something Wrong With PhysX", MB_OK | MB_ICONERROR | MB_TASKMODAL);
			exit(0);
		}

		if(!PxInitExtensions(*gPhysicsSDK))
			cerr<< "PxInitExtensions failed!" <<endl;
		

		PxSceneDesc	sceneDesc(gPhysicsSDK->getTolerancesScale());
		sceneDesc.gravity=PxVec3(0.0f, -9.8f, 0.0f);

		if(!sceneDesc.cpuDispatcher) {
			mCpuDispatcher = PxDefaultCpuDispatcherCreate(1);
			if(!mCpuDispatcher)
				cerr<<"PxDefaultCpuDispatcherCreate failed!"<<endl;
			sceneDesc.cpuDispatcher = mCpuDispatcher;
		} 
		
		if (!sceneDesc.gpuDispatcher && mCudaContextManager )
		{
			printf("gpu dispatcher done!\n");
			sceneDesc.gpuDispatcher = mCudaContextManager->getGpuDispatcher();
		}


		if(!sceneDesc.filterShader)
			sceneDesc.filterShader  = gDefaultFilterShader;

		gScene = gPhysicsSDK->createScene(sceneDesc);

		gSceneDesc=&sceneDesc;

		if (!gScene)
			cerr<<"createScene failed!"<<endl;



		//gScene->setVisualizationParameter(PxVisualizationParameter::eSCALE,				 1.0);
		//gScene->setVisualizationParameter(PxVisualizationParameter::eCOLLISION_SHAPES,	1.0f);
		//gScene->setVisualizationParameter(PxVisualizationParameter::eDEFORMABLE_MESH, 1.0f);
		//gScene->setVisualizationParameter(PxVisualizationParameter::eDEFORMABLE_SELFCOLLISIONS, 1.0f);
		//gScene->setVisualizationParameter(PxVisualizationParameter::eCOLLISION_DYNAMIC, 1.0f);
		//gScene->setVisualizationParameter(PxVisualizationParameter::eDEFORMABLE_SHAPES, 1.0f);

		PxMaterial* mMaterial = gPhysicsSDK->createMaterial(0.5,0.5,0.5);

		//Create actors 
		//1) Create ground plane
		PxReal d = 0.0f;	 
		PxTransform pose = PxTransform(PxVec3(0.0f, 0.0f, 0.0f),PxQuat(PxHalfPi, PxVec3(0.0f, 0.0f, 1.0f)));

		PxRigidStatic* plane = gPhysicsSDK->createRigidStatic(pose);
		if (!plane)
			cerr<<"create plane failed!"<<endl;

		PxShape* shape = plane->createShape(PxPlaneGeometry(), *mMaterial);
		if (!shape)
			cerr<<"create shape failed!"<<endl;
		gScene->addActor(*plane);

		return sceneDesc;
	}
	else
		return *gSceneDesc;
		
}

bool collider_set_up=false;
PxVec3 clothPos;
PxVec3 wind;
float curScale=1;

void InturlamDressingRoom::createCloth(PxSceneDesc sceneDesc)
{
	
	if (lowerCloth->cloth)
	{
		gScene->removeActor(*lowerCloth->cloth);
		lowerCloth->cloth->release();
		lowerCloth->cloth=0;
		lowerCloth->Reset();
	}
	bool withHanger=true;

	if (!collider_set_up)
		setupHumanCollider();	
	if (col_data.isValid())
		cloth=lowerCloth->loadPhysxCloth(col_data,&sceneDesc,gPhysicsSDK);
	if (cloth)
		gScene->addActor(*cloth);
	

	//meshDesc=*lowerCloth->loadPhysxCloth(&sceneDesc,fabric,points,&tr,gPhysicsSDK);

	//col_data.setToDefault();
	
	//clothDirection=still;
	clothRotation=none;
	guyMoves=standing;
}

void InturlamDressingRoom::loadClothes()
{
	for (int i=0;i<CLOTH_COUNT;i++)
	{
		Ogre::String baseName;
		if (skeletonClothNames[i]!="")
		{
			SkeletalMesh* tMesh=new SkeletalMesh(mKinect);
			baseName=skeletonClothNames[i].substr(0,skeletonClothNames[i].length()-5);
			tMesh->loadMesh(mSceneMgr,clothNode,baseName+"_skel",skeletonClothNames[i]);
			tMesh->setVisible(false);
			
			skeletalMeshes.push_back(tMesh);
		}
		else	
		{
			skeletalMeshes.push_back(0);
			baseName="NoUpper"+StringConverter::toString(i);
		}
		if (PhysicsClothNames[i]!="")
		{
			ObjObject* tPhys= new ObjObject(PhysicsClothNames[i].c_str());
			tPhys->Scale(SCALING_FACTOR);
			float vec3[3]={0,Y_OFFSET,0};
			tPhys->translate(vec3);
			Ogre::String meshName=baseName+"_free_mesh";
			Ogre::String entityName=baseName+"_free";
			tPhys->saveInitial();
			tPhys->loadIntoOgre(mSceneMgr, meshName);
			Ogre::Entity* lowerClothEntity=mSceneMgr->createEntity(entityName,meshName);
			lowerClothHandle->attachObject(lowerClothEntity);
			tPhys->entity=lowerClothEntity;
			tPhys->setVisible(false);
			physicsMeshes.push_back(tPhys);
		}
		else
			physicsMeshes.push_back(0);

	}
	if (skeletalMeshes.at(currentClothIndex))
	{
		upperCloth=skeletalMeshes.at(currentClothIndex);
		upperCloth->setVisible(true);
	}
	initializePhysics();
	if (physicsMeshes.at(currentClothIndex))
	{
		lowerCloth=physicsMeshes.at(currentClothIndex);
		lowerCloth->setVisible(true);
		createCloth(initializePhysics());
	}

	//Extra
	Ogre::MaterialPtr jMat=Ogre::MaterialManager::getSingleton().getByName("Jeans");
	jMat->getTechnique(0)->getPass(0)->setCullingMode(CULL_NONE);


	//Tunic-Vest
	//upperCloth->loadMesh(mSceneMgr,clothNode,"UpperCloth","Layer_12za.mesh");
	//lowerCloth=new ObjObject("../../media/wavefront/lowerTunic.obj");
}

bool justCalibrated=true;

void InturlamDressingRoom::changeCloth(int index)
{
	if (currentClothIndex!=index)
	{
		if (upperCloth)
			upperCloth->setVisible(false);
		if (skeletalMeshes.at(index))
		{
			upperCloth=skeletalMeshes.at(index);
			upperCloth->setVisible(true);
			if (!femaleBody->bNewUser && upperCloth->bNewUser)
			{
				upperCloth->origTorsoPos=femaleBody->origTorsoPos;
				upperCloth->bNewUser=false;
			}
		}
		else
		{
			upperCloth=0;
		}
		if (physicsMeshes.at(currentClothIndex))
		{
			lowerCloth->setVisible(false);
		}
		if (physicsMeshes.at(index))
		{
			lowerCloth=physicsMeshes.at(index);
			lowerCloth->setVisible(true);
			createCloth(initializePhysics());
		}
		else
		{
			lowerCloth=0;
		}
		justCalibrated=true;
		currentClothIndex=index;
	}

}
DWORD start_time=0;
DWORD latest_update=0;

//-------------------------------------------------------------------------------------
void InturlamDressingRoom::createScene(void)
{
	Ogre::OverlayElement* mDepthPanel = SetupDepthMaterial();
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mDepthPanel);
	#if USE_KINECT//Kinect And Stuff	
	mKinect=new KinectController(false);
	mKinect->createRTT(mRoot,mTrayMgr);
	mDepthPanel->show();
	#elif USE_NUI
	mNui=new NUI_Controller();
	#else
	mDepthPanel->hide();
	#endif
	
	
	#if USE_USER_SCALING == 0
	createSimulation();
	#endif

	buildAxes();
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.7, 0.7, 0.7));
	Ogre::Light* l = mSceneMgr->createLight("MainLight");
	l->setPosition(0,30,0);
	StringVector items;
	items.push_back("Passed Frames");
	items.push_back("Calibration Time");
	items.push_back("Body Height");
	items.push_back("Target Spheres");
	items.push_back("Radius");
	items.push_back("Elapsed MS");
	items.push_back("Left humerus yaw");
	items.push_back("Left humerus pitch");
	items.push_back("Left humerus roll");
	items.push_back("Right humerus yaw");
	items.push_back("Right humerus pitch");
	items.push_back("Right humerus roll");
	mTrayMgr->hideLogo();
	help = mTrayMgr->createParamsPanel(TL_NONE, "HelpMessage", 350, items);
	help->setParamValue("Target Spheres",boneStrings[targetRadii]);
	help->setParamValue("Radius",StringConverter::toString(box_collider[targetRadii].radius));
    help->hide();
	start_time=GetTickCount();
	latest_update=GetTickCount();
}

void InturlamDressingRoom::updateCollisionSpheres()
{
	Vector3 ColliderOffset=rootColliderNode->_getDerivedPosition();
	Quaternion ColliderOrientation=femaleBody->getBoneOrientation(BONE_ROOT).Inverse();
	for (int i=0;i<COLLISION_SPHERE_COUNT;i++)
	{
		Ogre::String nodeName=boneStrings[i]+"Node";
		Ogre::SceneNode* gNode=mSceneMgr->getSceneNode(nodeName);
		Vector3 localPosition=ColliderOrientation*(gNode->_getDerivedPosition()+Vector3(0,Y_OFFSET,0)-ColliderOffset);
		if (boneStrings[i]=="Root")
		{
			box_collider[i].pos.x=localPosition.x;
			box_collider[i].pos.y=localPosition.y;
			box_collider[i].pos.z=localPosition.z;
		}
		else
		{
			box_collider[i].pos.x=localPosition.x;
			box_collider[i].pos.y=localPosition.y;
			box_collider[i].pos.z=localPosition.z;
		}
	}
	cloth->setCollisionSpheres(box_collider);
}

void InturlamDressingRoom::updateCloth()
{
	Vector3 ts=lowerClothHandle->getPosition()+Vector3(0,Y_OFFSET,0);
	PxVec3 trans=PxVec3(ts.x,ts.y,ts.z);
	Ogre::Quaternion qRot=femaleBody->getBoneOrientation(BONE_ROOT);
	PxQuat quat(qRot.x,qRot.y,qRot.z,qRot.w);
	if (justCalibrated)
	{
		cloth->setGlobalPose(PxTransform(trans,quat));
		justCalibrated=false;
	}
	else
		cloth->setTargetPose(PxTransform(trans,quat));
	updateCollisionSpheres();
}

void InturlamDressingRoom::updateJoints(Ogre::Bone* bone,int level)
{
	if (bone->numChildren()>0 && level<7)
	{
		Ogre::String boneName=bone->getName();
		if (!bone->getInheritOrientation())
		{
			Ogre::SceneNode* jointNode=mSceneMgr->getSceneNode(boneName + "Node");
			#if USE_KINECT
			Ogre::Quaternion qI = boneNode->getInitialOrientation();
			#else
			Ogre::Quaternion qI = Ogre::Quaternion::IDENTITY;
			#endif
			jointNode->setOrientation(bone->getOrientation()*qI);
		}
		Ogre::Bone::ChildNodeIterator childIterator=bone->getChildIterator();
		while(childIterator.hasMoreElements())
			updateJoints((Ogre::Bone*)childIterator.getNext(),level+1);
	}
}

void InturlamDressingRoom::updateVisualHuman()
{
#if USE_KINECT
	Ogre::Vector3 leftHip=mKinect->getRealCoordinate(XN_SKEL_LEFT_HIP);
	Ogre::Vector3 rightHip=mKinect->getRealCoordinate(XN_SKEL_RIGHT_HIP);
	Ogre::Vector3 hipVector=(rightHip-leftHip);
	Ogre::Vector3 initialVector=Ogre::Vector3(1,0,0);
	hipVector.y=0;
	bodyRotation=hipVector.getRotationTo(initialVector);
#endif
	Ogre::Bone* rootBone=femaleBody->getSkeleton()->getBone("Root");
	//Ogre::SceneNode* coreBone=mSceneMgr->getSceneNode("Root to Waist Node");
	//coreBone->setOrientation(rootBone->getOrientation());
	updateJoints(rootBone);

}

long long milliseconds_now() {
    static LARGE_INTEGER s_frequency;
    static BOOL s_use_qpc = QueryPerformanceFrequency(&s_frequency);
    if (s_use_qpc) {
        LARGE_INTEGER now;
        QueryPerformanceCounter(&now);
        return (1000LL * now.QuadPart) / s_frequency.QuadPart;
    } else {
        return GetTickCount();
    }
}

PxReal timeStep=0;
int initialDelay=0;
float totalCalibrationTime=0;
bool calibrated=false;
long long cal_start;
long long cal_end;

PxVec3 acceleration=PxVec3(0);
void InturlamDressingRoom::updateAcceleration(PxVec3 add)
{
	acceleration+=add;
	cloth->setExternalAcceleration(acceleration);
}
bool InturlamDressingRoom::keyPressed( const OIS::KeyEvent &arg )
{
	if (arg.key==OIS::KC_SPACE)
		simulating=!simulating;
	else if (arg.key==OIS::KC_L)
	{
		Ogre::Vector3 vp=mCamera->getPosition();
		Ogre::Quaternion vq=mCamera->getOrientation();
		vq=vq;
	}
	else if (arg.key==OIS::KC_H)
		femaleNode->flipVisibility();
	else if (arg.key==OIS::KC_C)
		rootColliderNode->flipVisibility();
	else if (arg.key==OIS::KC_V)
	{
		if (upperCloth)
			upperCloth->flipVisibility();
	}
	else if (arg.key==OIS::KC_B)
	{	
		if (lowerCloth)
			lowerCloth->flipVisibility();
	}
	else if (arg.key==OIS::KC_P)
	{
		help->setParamValue("Right humerus roll",StringConverter::toString(femaleBody->rollManually("Humerus.R",5)));
	}
	else if (arg.key==OIS::KC_O)
	{	
		
		help->setParamValue("Right humerus roll",StringConverter::toString(femaleBody->rollManually("Humerus.R",-5)));
	}
	
	else if (arg.key==OIS::KC_ADD)
	{
		//PxReal scale=cloth->getInertiaScale();
		//if (scale<=0.9)
		//	cloth->setInertiaScale(scale+0.1);
		box_collider[targetRadii].radius+=0.1;
		box_collider[targetRadii+1].radius+=0.1;
		help->setParamValue("Radius",StringConverter::toString(box_collider[targetRadii].radius));
		updateCollisionSpheres();
	}
	else if (arg.key==OIS::KC_SUBTRACT)
	{
		//PxReal scale=cloth->getInertiaScale();
		//if (scale>=0.1)
		//	cloth->setInertiaScale(scale-0.1);
		box_collider[targetRadii].radius-=0.1;
		box_collider[targetRadii+1].radius-=0.1;
		help->setParamValue("Radius",StringConverter::toString(box_collider[targetRadii].radius));
		updateCollisionSpheres();
	}
	else if (arg.key==OIS::KC_M)
	{
		targetRadii+=2;
		help->setParamValue("Target Spheres",boneStrings[targetRadii]);
		help->setParamValue("Radius",StringConverter::toString(box_collider[targetRadii].radius));
	}
	else if (arg.key==OIS::KC_N)
	{	
		targetRadii-=2;
		help->setParamValue("Target Spheres",boneStrings[targetRadii]);
		help->setParamValue("Radius",StringConverter::toString(box_collider[targetRadii].radius));
	}
	
	else if (arg.key==OIS::KC_J)
	{
		if (help->getTrayLocation() == OgreBites::TL_NONE)
        {
            mTrayMgr->moveWidgetToTray(help, OgreBites::TL_TOPRIGHT, 0);
            help->show();
        }
        else
        {
            mTrayMgr->removeWidgetFromTray(help);
            help->hide();
        }
	}
	else if (arg.key==OIS::KC_TAB)
	{
		usingGPU=!usingGPU;
		cloth->setClothFlag(PxClothFlag::eGPU,usingGPU);
	}
	else if (arg.key==OIS::KC_NUMPAD8)
		updateAcceleration(PxVec3(0,0,1));
	else if (arg.key==OIS::KC_NUMPAD2)
		updateAcceleration(PxVec3(0,0,-1));
	else if (arg.key==OIS::KC_NUMPAD6)
		updateAcceleration(PxVec3(1,0,0));
	else if (arg.key==OIS::KC_NUMPAD4)
		updateAcceleration(PxVec3(-1,0,0));
	else if (arg.key==OIS::KC_NUMPAD5)
		updateAcceleration(-acceleration);
	else if (arg.key==OIS::KC_1)
		changeCloth(0);
	else if (arg.key==OIS::KC_2)
		changeCloth(1);
	else if (arg.key==OIS::KC_3)
		changeCloth(2);
	else if (arg.key==OIS::KC_4)
		changeCloth(3);
	else if (arg.key==OIS::KC_5)
		changeCloth(4);
	return BaseApplication::keyPressed(arg);
}

bool InturlamDressingRoom::keyReleased( const OIS::KeyEvent &arg )
{
	if (arg.key==OIS::KC_NUMPAD8 || arg.key==OIS::KC_NUMPAD5 || arg.key==OIS::KC_NUMPAD6 || arg.key==OIS::KC_NUMPAD4)
		clothDirection=still;
	else if (arg.key==OIS::KC_NUMPAD7 || arg.key==OIS::KC_NUMPAD9)
		clothRotation=none;
	else if (arg.key==OIS::KC_NUMPAD1 || arg.key==OIS::KC_NUMPAD3)
		guyMoves=standing;
	return BaseApplication::keyReleased(arg);
}

Ogre::AnimationState* leftArm,*rightArm;

void assignWeightsToBones(Ogre::Bone* bone,Ogre::AnimationState* anim)
{
	Ogre::Node::ChildNodeIterator c=bone->getChildIterator();
	while(c.hasMoreElements())
	{
		Ogre::Bone* cBone=(Ogre::Bone*)c.getNext();
		anim->setBlendMaskEntry(cBone->getHandle(),1);
		assignWeightsToBones(cBone,anim);
	}
}


void InturlamDressingRoom::createSimulation()
{
	#if USE_USER_SCALING
	userHeightScale=SCALING_FACTOR*estimatedTorsoHeight/MODEL_TORSO_HEIGHT;
	userWidthScale=SCALING_FACTOR*estimatedShoulderWidth/MODEL_SHOULDER_WIDTH;
	userDepthScale=(userHeightScale+userWidthScale)/2;
	#else
	userHeightScale=SCALING_FACTOR;
	userWidthScale=SCALING_FACTOR;
	userDepthScale=SCALING_FACTOR;
	#endif

	clothHandle=mSceneMgr->getRootSceneNode()->createChildSceneNode();
	clothNode=clothHandle->createChildSceneNode("ClothNode");
	femaleNode=clothHandle->createChildSceneNode("FemaleHandle");
	lowerClothHandle=clothHandle->createChildSceneNode("lowerClothHandle",Vector3(0,-Y_OFFSET,0));

	femaleBody=new SkeletalMesh(mKinect);
	femaleBody->loadMesh(mSceneMgr,femaleNode,"FemaleModel","FemaleBody.mesh");

	//Animation
	//Ogre::AnimationStateSet* ass=femaleBody->Mesh->getAllAnimationStates();
	//Ogre::AnimationStateIterator s=ass->getAnimationStateIterator();
	leftArm=femaleBody->Mesh->getAnimationState("LeftArm");
	leftArm->setLoop(true);
	leftArm->setEnabled(true);
	rightArm=femaleBody->Mesh->getAnimationState("RightArm");
	rightArm->setLoop(true);
	rightArm->setEnabled(true);
	
	Ogre::SkeletonInstance* fSkel=femaleBody->Mesh->getSkeleton();
	leftArm->createBlendMask(fSkel->getNumBones(),0);
	rightArm->createBlendMask(fSkel->getNumBones(),0);
	assignWeightsToBones(fSkel->getBone("Hand.L"),leftArm);
	assignWeightsToBones(fSkel->getBone("Hand.R"),rightArm);
	//End-Animation

	createVisualHuman();
	loadClothes();
	
	clothNode->scale(userWidthScale,userHeightScale,userDepthScale);
	femaleNode->scale(userWidthScale,userHeightScale,userDepthScale);
	rootColliderNode->scale(SCALING_FACTOR,SCALING_FACTOR,SCALING_FACTOR);
	//clothNode->setVisible(false);
	//lowerClothHandle->setVisible(false);
	//femaleNode->setVisible(false);
	rootColliderNode->setVisible(false);
	simulationCreated=true;
}

bool InturlamDressingRoom::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	#if USE_KINECT
	if (mKinect->addTime(evt.timeSinceLastFrame))
	{
		if (mKinect->isUserActive())
		{
			if (mKinect->m_UserGenerator.GetSkeletonCap().IsCalibrated(mKinect->activeUser))
			{
				#if USE_USER_SCALING
				if (calibrated && simulationCreated)
				{
					upperCloth->setUserID(mKinect->activeUser);
					Ogre::Vector3 targetPos=upperCloth->updateMesh();
					femaleBody->setUserID(mKinect->activeUser);
					femaleBody->updateMesh();
					updateVisualHuman();
					lowerClothHandle->setPosition(targetPos*Vector3(SCALING_FACTOR,SCALING_FACTOR,SCALING_FACTOR)+Vector3(0,-Y_OFFSET,0));
					lowerClothHandle->setOrientation(upperCloth->getBoneOrientation(BONE_ROOT));
					updateCloth();
				}
				else if (initialDelay>6)
				{
					if (addFrame(&mKinect->m_DepthGenerator,&mKinect->m_UserGenerator,mKinect->activeUser))
					{
						calibrated=true;
						cal_end=milliseconds_now();
						totalCalibrationTime+=((float)cal_end-(float)cal_start)/1000;	
						help->setParamValue("Calibration Time",StringConverter::toString(totalCalibrationTime));
						help->setParamValue("Body Height",StringConverter::toString(estimatedBodyHeight));
						help->setParamValue("Shoulder Width",StringConverter::toString(estimatedShoulderWidth));
						createSimulation();
					}
				}
				else
				{
					initialDelay+=1;	
					help->setParamValue("Passed Frames",StringConverter::toString(initialDelay));
					if (initialDelay>6) cal_start=milliseconds_now();
				}
				#else
				upperCloth->setUserID(mKinect->activeUser);
				upperCloth->updateMesh();
				femaleBody->setUserID(mKinect->activeUser);
				Ogre::Vector3 targetPos=femaleBody->updateMesh();
				updateVisualHuman();
				if (lowerCloth)
				{
					lowerClothHandle->setPosition(targetPos*Vector3(SCALING_FACTOR,SCALING_FACTOR,SCALING_FACTOR)+Vector3(0,-Y_OFFSET,0));
					lowerClothHandle->setOrientation(upperCloth->getBoneOrientation(BONE_ROOT));
					updateCloth();
				}
				#endif
			}
			else if (simulationCreated)
			{
				femaleBody->resetBonesToInitialState();
				upperCloth->resetBonesToInitialState();
				updateVisualHuman();
			}
		}
		else if (simulationCreated)
		{
			femaleBody->resetBonesToInitialState();
			upperCloth->resetBonesToInitialState();
			updateVisualHuman();
		}
	}
	#endif
	#if USE_NUI
	updateDepthTexture();
	if (mNui->mSkeletonUpdated)
	{
		if (upperCloth)
			upperCloth->updateMesh(mNui);
		Ogre::Vector3 targetPos=femaleBody->updateMesh(mNui);
		
		updateVisualHuman();
		if (lowerCloth)
		{
			lowerClothHandle->setPosition(targetPos*Vector3(SCALING_FACTOR,SCALING_FACTOR,SCALING_FACTOR)+Vector3(0,-Y_OFFSET,0));
			lowerClothHandle->setOrientation(femaleBody->getBoneOrientation(BONE_ROOT));
			rootColliderNode->setPosition(targetPos*Vector3(SCALING_FACTOR,SCALING_FACTOR,SCALING_FACTOR));
			updateCloth();
		}
		mNui->mSkeletonUpdated=false;

		//	Hand animation
		Quaternion q;
		Ogre::Matrix3 tMat;Radian yaw,pitch,roll;
		NUI_SKELETON_BONE_ORIENTATION rightUlna=mNui->m_Orientations[NUI_SKELETON_POSITION_WRIST_RIGHT];
		q.x=rightUlna.hierarchicalRotation.rotationQuaternion.x;
		q.y=rightUlna.hierarchicalRotation.rotationQuaternion.y;
		q.z=rightUlna.hierarchicalRotation.rotationQuaternion.z;
		q.w=rightUlna.hierarchicalRotation.rotationQuaternion.w;
		q.ToRotationMatrix(tMat);	
		tMat.ToEulerAnglesYZX(yaw,pitch,roll);
		float rUlnaCurl=1.3*roll.valueRadians()/Ogre::Math::PI;
		rightArm->setTimePosition(rUlnaCurl);

		NUI_SKELETON_BONE_ORIENTATION leftUlna=mNui->m_Orientations[NUI_SKELETON_POSITION_WRIST_LEFT];
		q.x=leftUlna.hierarchicalRotation.rotationQuaternion.x;
		q.y=leftUlna.hierarchicalRotation.rotationQuaternion.y;
		q.z=leftUlna.hierarchicalRotation.rotationQuaternion.z;
		q.w=leftUlna.hierarchicalRotation.rotationQuaternion.w;
		q.ToRotationMatrix(tMat);	
		tMat.ToEulerAnglesYZX(yaw,pitch,roll);
		float lUlnaCurl=1.3*roll.valueRadians()/Ogre::Math::PI;
		leftArm->setTimePosition(lUlnaCurl);




		//Arm Testing
		NUI_SKELETON_BONE_ORIENTATION rightHumerus=mNui->m_Orientations[NUI_SKELETON_POSITION_WRIST_RIGHT];
		q.x=rightHumerus.hierarchicalRotation.rotationQuaternion.x;
		q.y=rightHumerus.hierarchicalRotation.rotationQuaternion.y;
		q.z=rightHumerus.hierarchicalRotation.rotationQuaternion.z;
		q.w=rightHumerus.hierarchicalRotation.rotationQuaternion.w;
		Ogre::Matrix3 rotM;
		q.ToRotationMatrix(rotM);
		rotM.ToEulerAnglesZXY(yaw,pitch,roll);
		help->setParamValue("Right humerus yaw",StringConverter::toString(yaw));
		help->setParamValue("Right humerus pitch",StringConverter::toString(pitch));
		help->setParamValue("Right humerus roll",StringConverter::toString(roll));


		//NUI_SKELETON_BONE_ORIENTATION leftHumerus=mNui->m_Orientations[NUI_SKELETON_POSITION_ELBOW_LEFT];
		//q.x=leftHumerus.absoluteRotation.rotationQuaternion.x;
		//q.y=leftHumerus.absoluteRotation.rotationQuaternion.y;
		//q.z=leftHumerus.absoluteRotation.rotationQuaternion.z;
		//q.w=leftHumerus.absoluteRotation.rotationQuaternion.w;
		q.ToRotationMatrix(rotM);
		rotM.ToEulerAnglesZXY(yaw,pitch,roll);
		help->setParamValue("Left humerus yaw",StringConverter::toString(yaw));
		help->setParamValue("Left humerus pitch",StringConverter::toString(pitch));
		help->setParamValue("Left humerus roll",StringConverter::toString(roll));
		
		

	}
	#endif 
	if (simulating && lowerCloth)
	{
		DWORD t=GetTickCount();
		float elapsed=t-latest_update;
		if (elapsed>8)
		{
			updateCollisionSpheres();
			lowerCloth->updateWithPhysics(gScene,elapsed/1000);
			latest_update=GetTickCount();
		}	
	}

	help->setParamValue("Elapsed MS",StringConverter::toString(((float)(GetTickCount()-start_time))/1000));

	return BaseApplication::frameRenderingQueued(evt);
}

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
	int main(int argc, char *argv[])
#endif
	{
		// Create application object
		InturlamDressingRoom app;

		try {
			app.go();
		} catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
			MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
			std::cerr << "An exception has occured: " <<
				e.getFullDescription().c_str() << std::endl;
#endif
		}

		return 0;
	}

#ifdef __cplusplus
}
#endif
